<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>WebGL Test</title>
<style>
body {
  font-family: sans-serif;
  margin: 0;
  background-color: #fff;
  overflow: hidden;
}
canvas { width: 100%; height: 100% }
</style>
</head>
<body>
  <div id="container"></div>
<script src="js/three.min.js"></script>
<script>
'use strict';

var scene;
var camera;
var renderer;

var container;

var raycaster = new THREE.Raycaster();
var mouse = new THREE.Vector2();
var onClickPosition = new THREE.Vector2();

var cube;

var site = 'http://news.ycombinator.com';
var reqURL = '/samples/data/hn-imagemap.json';
var links = [];

var width = 512;
var height = 512;


init();
animate();

function init() {
  container = document.getElementById( 'container' );

  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 100 );

  renderer = new THREE.WebGLRenderer({
    antialias: false
  });
  renderer.setSize( window.innerWidth, window.innerHeight );
  container.appendChild( renderer.domElement );

  addTexturedCube();

  scene.addEventListener('click', function(event){
    var position = convertUVToPosition(event.uvs, width, height);
    console.log(position);

    let link = getLinkAt(links, position);
    if (link)
      console.log('clicked: ' + link.href);
  });

  camera.position.z = 1.5;

  window.addEventListener( 'resize', onWindowResize, false );
  container.addEventListener( 'mousedown', onMouseAction, false );
}

// return path
async function getData(request) {
  let resp = await fetch(request);
  let data = await resp.json();
  return data;
}

async function addTexturedCube() {
  var data = await getData(reqURL);
  var path = data.path;
  console.log(path);
  links = data.links;

  var texture = new THREE.TextureLoader().load( '/'+path );
  var material = new THREE.MeshBasicMaterial( { map: texture } );

  var geometry = new THREE.BoxGeometry( 1, 1, 1 );
  cube = new THREE.Mesh( geometry, material );
  scene.add( cube );
}

function getLinkAt(links, position) {
  let link;
  // reverse order to match inverse tree order
  // likely gets correct link if two on top
  for (var i = links.length-1; i >= 0; i--) {
    if (insideBox(position[0], position[1], links[i])) {
      link = links[i];
      break;
    }
  }
  return link;
}

// box : { x,y,width,height }
function insideBox(x,y, box) {
  if (x < box.x || y < box.y || x > box.x+box.width || y > box.y+box.height)
    return false;
  return true;
}

function convertUVToPosition(uv, width, height) {
  var x = Math.round(uv.x * width);
  var y = Math.round(uv.y * height);
  return [x,y];
}

// check
function checkMap() {

}

function animate() {
  window.requestAnimationFrame( animate );

  update();
  render();
}

function update() {
  if (cube)
    cube.rotation.y += 0.003;
}

function render() {
  renderer.render( scene, camera );
}

function onMouseAction( evt ) {
  evt.preventDefault();
  var array = getMousePosition( container, evt.clientX, evt.clientY );
  onClickPosition.fromArray( array );
  var intersects = getIntersects( onClickPosition, scene.children );
  if ( intersects.length > 0 && intersects[ 0 ].uv ) {
    var uv = intersects[ 0 ].uv;
    intersects[ 0 ].object.material.map.transformUv( uv );
    var uvs = { x: uv.x.toFixed(4), y: uv.y.toFixed(4) };
    console.log( uvs );

    scene.dispatchEvent({type: 'click', message: 'clicked', uvs: uvs });
  }
}

var getMousePosition = function ( dom, x, y ) {
  var rect = dom.getBoundingClientRect();
  return [ ( x - rect.left ) / rect.width, ( y - rect.top ) / rect.height ];
};

var getIntersects = function ( point, objects ) {
  mouse.set( ( point.x * 2 ) - 1, - ( point.y * 2 ) + 1 );
  raycaster.setFromCamera( mouse, camera );
  return raycaster.intersectObjects( objects );
};

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize( window.innerWidth, window.innerHeight );
}
</script>
</body>
</html>