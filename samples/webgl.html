<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>WebGL Test</title>
<style>
body {
  font-family: sans-serif;
  margin: 0;
  background-color: #fff;
  overflow: hidden;
}
canvas { width: 100%; height: 100% }
</style>
</head>
<body>
  <div id="container"></div>
<script src="js/three.min.js"></script>
<script>
'use strict';

var scene;
var camera;
var renderer;

var container;

var raycaster = new THREE.Raycaster();
var mouse = new THREE.Vector2();
var onClickPosition = new THREE.Vector2();

var cube;

var site = 'http://news.ycombinator.com';
var reqURL = '/samples/data/hn-imagemap.json';


init();
animate();

function init() {
  container = document.getElementById( 'container' );

  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 100 );

  renderer = new THREE.WebGLRenderer({
    antialias: false
  });
  renderer.setSize( window.innerWidth, window.innerHeight );
  container.appendChild( renderer.domElement );

  addTexturedCube();

  camera.position.z = 1.5;

  window.addEventListener( 'resize', onWindowResize, false );
  container.addEventListener( 'mousedown', onMouseAction, false );
}

// return path
async function getPath(request) {
  let resp = await fetch(request);
  let data = await resp.json();
  return data.path;
}

async function addTexturedCube() {
  var path = await getPath(reqURL);
  console.log(path);

  var texture = new THREE.TextureLoader().load( '/'+path );
  var material = new THREE.MeshBasicMaterial( { map: texture } );

  var geometry = new THREE.BoxGeometry( 1, 1, 1 );
  cube = new THREE.Mesh( geometry, material );
  scene.add( cube );
}


function animate() {
  window.requestAnimationFrame( animate );

  update();
  render();
}

function update() {
  if (cube)
    cube.rotation.y += 0.007;
}

function render() {
  renderer.render( scene, camera );
}

function onMouseAction( evt ) {
  evt.preventDefault();
  var array = getMousePosition( container, evt.clientX, evt.clientY );
  onClickPosition.fromArray( array );
  var intersects = getIntersects( onClickPosition, scene.children );
  if ( intersects.length > 0 && intersects[ 0 ].uv ) {
    var uv = intersects[ 0 ].uv;
    intersects[ 0 ].object.material.map.transformUv( uv );
    console.log( uv.x.toFixed(4), uv.y.toFixed(4) );
  }
}

var getMousePosition = function ( dom, x, y ) {
  var rect = dom.getBoundingClientRect();
  return [ ( x - rect.left ) / rect.width, ( y - rect.top ) / rect.height ];
};

var getIntersects = function ( point, objects ) {
  mouse.set( ( point.x * 2 ) - 1, - ( point.y * 2 ) + 1 );
  raycaster.setFromCamera( mouse, camera );
  return raycaster.intersectObjects( objects );
};

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize( window.innerWidth, window.innerHeight );
}
</script>
</body>
</html>