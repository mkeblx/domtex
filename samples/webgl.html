<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>WebGL Test</title>
<style>
body {
  font-family: sans-serif;
  margin: 0;
  background-color: #fff;
  overflow: hidden;
}
canvas { width: 100%; height: 100% }
</style>
</head>
<body>
  <div id="container"></div>
<script src="js/domtex.js"></script>
<script src="js/three.min.js"></script>
<script>
'use strict';

var clock = new THREE.Clock();

var scene;
var camera;
var renderer;

var container;


var raycaster = new THREE.Raycaster();
var mouse = new THREE.Vector2();
var onClickPosition = new THREE.Vector2();

var group;
var cube;

var loading;

var _tex;

var reqURL;
var site = 'http://localhost:8000/samples/test.html';
var sels = ['#box1','#box2','#box3'];
var atlas = true;
var force = true;
var params = {
  url: site,
  sel: sels.join(','),
  atlas: atlas,
  force: force };

var width = 512;
var height = 512;


init();
animate();

function init() {
  container = document.getElementById( 'container' );

  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 100 );

  renderer = new THREE.WebGLRenderer({
    antialias: true
  });
  renderer.setSize( window.innerWidth, window.innerHeight );
  container.appendChild( renderer.domElement );

  scene.addEventListener('click', function(event){
    var position = convertUVToPosition(event.uvs, width, height);
    console.log(position);
  });

  camera.position.z = 1.0;

  window.addEventListener( 'resize', onWindowResize, false );

  addLoadingIndicator();

  group = new THREE.Object3D();
  group.position.y = 0.3;
  scene.add(group);

  addElements();
}

function addLoadingIndicator() {
  loading = new THREE.Mesh(
    new THREE.RingGeometry( 0.1, 0.13, 60, 1, 0, Math.PI * 2 / 3 ),
     new THREE.MeshBasicMaterial( {  } ) );
  scene.add(loading);
}

// return path
async function getData(request) {
  let resp = await fetch(request);
  let data = await resp.json();
  return data;
}

async function addElements() {
  var reqURL = generateRequestUrl(params);
  console.log(reqURL);
  var data = await getData(reqURL);
  console.log(data);

  scene.remove(loading);

  var i = 0;
  var doc = data.textures['document'];
  var y = 0;
  for (let sel in data.textures) {
    if (sel === 'document')
      continue;
    var tex = data.textures[sel];
    console.log(tex);

    var path = tex.path;
    var aspect = tex.width / tex.height;
    var texture = new THREE.TextureLoader().load( '/'+path );

    if (atlas) {
      texture.repeat.x = tex.width / doc.width;
      texture.repeat.y = tex.height / doc.height;

      var offsetX = tex.x / doc.width;
      var offsetY = ( ( doc.height - tex.height - tex.y ) / doc.height );
      texture.offset.x = offsetX;
      texture.offset.y = offsetY;

      //console.log(texture.repeat);
      //console.log(texture.offset);

      _tex = texture;

      tex.needsUpdate = true;
    }

    var material = new THREE.MeshBasicMaterial( { map: texture } );

    var s = 1 / 512;
    var geometry = new THREE.BoxGeometry( tex.width * s, tex.height * s, tex.width * s * 0.05 );
    cube = new THREE.Mesh( geometry, material );

    cube.position.y = y;

    console.log(y);
    y -= (tex.height * s);


    group.add( cube );

    i++;
  }
}

function convertUVToPosition(uv, width, height) {
  var x = Math.round(uv.x * width);
  var y = Math.round(uv.y * height);
  return [x,y];
}

// check
function checkMap() {

}

function animate(t) {
  window.requestAnimationFrame( animate );

  var dt = clock.getDelta();

  update(t, dt);
  render(t, dt);
}

var r = 0;
function update(t, dt) {
  if (loading) {
    r += dt;
    loading.rotation.set( 0, 0, -r*4);
  }
  //if (cube)
  //  cube.rotation.y += 0.003;
}

function render(t, dt) {
  renderer.render( scene, camera );
}

var getMousePosition = function ( dom, x, y ) {
  var rect = dom.getBoundingClientRect();
  return [ ( x - rect.left ) / rect.width, ( y - rect.top ) / rect.height ];
};

var getIntersects = function ( point, objects ) {
  mouse.set( ( point.x * 2 ) - 1, - ( point.y * 2 ) + 1 );
  raycaster.setFromCamera( mouse, camera );
  return raycaster.intersectObjects( objects );
};

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize( window.innerWidth, window.innerHeight );
}
</script>
</body>
</html>