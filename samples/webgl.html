<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>WebGL Test</title>
<style>
body {
  font-family: sans-serif;
  margin: 0;
  background-color: #fff;
  overflow: hidden;
}
canvas { width: 100%; height: 100% }
</style>
</head>
<body>
  <div id="container"></div>
<script src="js/domtex.js"></script>
<script src="js/three.min.js"></script>
<script>
'use strict';

var scene;
var camera;
var renderer;

var container;

var raycaster = new THREE.Raycaster();
var mouse = new THREE.Vector2();
var onClickPosition = new THREE.Vector2();

var cube;

var reqURL;
var site = 'http://news.ycombinator.com';
var sels = ['.pagetop','.hnname'];
var atlas = false;
var force = true;
var params = {
  url: site,
  sel: sels.join(','),
  atlas: atlas,
  force: force };

var width = 512;
var height = 512;


init();
animate();

function init() {
  container = document.getElementById( 'container' );

  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 100 );

  renderer = new THREE.WebGLRenderer({
    antialias: true
  });
  renderer.setSize( window.innerWidth, window.innerHeight );
  container.appendChild( renderer.domElement );

  scene.addEventListener('click', function(event){
    var position = convertUVToPosition(event.uvs, width, height);
    console.log(position);
  });

  camera.position.z = 1.5;

  window.addEventListener( 'resize', onWindowResize, false );


  addElements();
}

// return path
async function getData(request) {
  let resp = await fetch(request);
  let data = await resp.json();
  return data;
}

async function addElements() {
  var reqURL = generateRequestUrl(params);
  console.log(reqURL);
  var data = await getData(reqURL);
  console.log(data);

  var i = 0;
  for (let sel in data.textures) {
    if (sel === 'document')
      continue;
    var tex = data.textures[sel];
    console.log(tex);

    var path = tex.path;
    var aspect = tex.width / tex.height;
    var texture = new THREE.TextureLoader().load( '/'+path );
    var material = new THREE.MeshBasicMaterial( { map: texture } );

    var s = 1 / 512;
    var geometry = new THREE.BoxGeometry( tex.width * s, tex.height * s, tex.width * s );
    cube = new THREE.Mesh( geometry, material );
    cube.position.y = i / 10;
    scene.add( cube );

    i++;
  }
}

function convertUVToPosition(uv, width, height) {
  var x = Math.round(uv.x * width);
  var y = Math.round(uv.y * height);
  return [x,y];
}

// check
function checkMap() {

}

function animate() {
  window.requestAnimationFrame( animate );

  update();
  render();
}

function update() {
  if (cube)
    cube.rotation.y += 0.003;
}

function render() {
  renderer.render( scene, camera );
}

var getMousePosition = function ( dom, x, y ) {
  var rect = dom.getBoundingClientRect();
  return [ ( x - rect.left ) / rect.width, ( y - rect.top ) / rect.height ];
};

var getIntersects = function ( point, objects ) {
  mouse.set( ( point.x * 2 ) - 1, - ( point.y * 2 ) + 1 );
  raycaster.setFromCamera( mouse, camera );
  return raycaster.intersectObjects( objects );
};

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize( window.innerWidth, window.innerHeight );
}
</script>
</body>
</html>